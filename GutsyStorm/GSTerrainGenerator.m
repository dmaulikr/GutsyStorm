//
//  GSTerrainGenerator.m
//  GutsyStorm
//
//  Created by Andrew Fox on 5/1/16.
//  Copyright Â© 2016 Andrew Fox. All rights reserved.
//

#import "GSTerrainGenerator.h"
#import "GSNoise.h"
#import "GSBox.h"
#import "GSVectorUtils.h"


static float groundGradient(float terrainHeight, vector_float3 p);
static void generateTerrainVoxel(GSNoise * _Nonnull noiseSource0, GSNoise * _Nonnull noiseSource1,
                                 float terrainHeight, vector_float3 p, GSVoxel * _Nonnull outVoxel);

@implementation GSTerrainGenerator
{
    GSNoise *_noiseSource0;
    GSNoise *_noiseSource1;
}

- (nonnull instancetype)init
{
    @throw nil;
}

- (nonnull instancetype)initWithRandomSeed:(NSInteger)seed
{
    if (self = [super init]) {
        _noiseSource0 = [[GSNoise alloc] initWithSeed:seed];
        _noiseSource1 = [[GSNoise alloc] initWithSeed:seed+1];
    }
    return self;
}

- (void)generateWithDestination:(nonnull GSVoxel *)voxels
                          count:(NSUInteger)count
                         region:(nonnull GSIntAABB *)box
                  offsetToWorld:(vector_float3)offsetToWorld
{
    NSParameterAssert(voxels);
    NSParameterAssert(box);
    
    const static float terrainHeight = 40.0f;
    vector_long3 clp;
    
    // First, generate voxels for a region of terrain.
    FOR_BOX(clp, *box)
    {
        vector_float3 worldPosition = vector_make(clp.x, clp.y, clp.z) + offsetToWorld;
        GSVoxel *voxel = &voxels[INDEX_BOX(clp, *box)];
        generateTerrainVoxel(_noiseSource0, _noiseSource1, terrainHeight, worldPosition, voxel);
    }
}

@end


// Return a value between -1 and +1 so that a line through the y-axis maps to a smooth gradient of values from -1 to +1.
static float groundGradient(float terrainHeight, vector_float3 p)
{
    const float y = p.y;
    
    if(y < 0.0) {
        return -1;
    } else if(y > terrainHeight) {
        return +1;
    } else {
        return 2.0*(y/terrainHeight) - 1.0;
    }
}

// Generates a voxel for the specified point in space. Returns that voxel in `outVoxel'.
static void generateTerrainVoxel(GSNoise * _Nonnull noiseSource0, GSNoise * _Nonnull noiseSource1,
                                 float terrainHeight, vector_float3 p, GSVoxel * _Nonnull outVoxel)
{
    BOOL groundLayer = NO;
    BOOL floatingMountain = NO;
    
    assert(outVoxel);
    
    // Normal rolling hills
    {
        const float freqScale = 0.025;
        float n = [noiseSource0 noiseAtPointWithFourOctaves:(p * freqScale)];
        float turbScaleX = 2.0;
        float turbScaleY = terrainHeight / 2.0;
        float yFreq = turbScaleX * ((n+1) / 2.0);
        float t = turbScaleY * [noiseSource1 noiseAtPoint:vector_make(p.x*freqScale, p.y*yFreq*freqScale, p.z*freqScale)];
        groundLayer = groundGradient(terrainHeight, vector_make(p.x, p.y + t, p.z)) <= 0;
    }
    
    // Giant floating mountain
    {
        /* The floating mountain is generated by starting with a sphere and applying turbulence to the surface.
         * The upper hemisphere is also squashed to make the top flatter.
         */
        
        vector_float3 mountainCenter = vector_make(50, 50, 80);
        vector_float3 toMountainCenter = mountainCenter - p;
        float distance = vector_length(toMountainCenter);
        float radius = 30.0;
        
        // Apply turbulence to the surface of the mountain.
        float freqScale = 0.70;
        float turbScale = 15.0;
        
        // Avoid generating noise when too far away from the center to matter.
        if(distance > 2.0*radius) {
            floatingMountain = NO;
        } else {
            // Convert the point into spherical coordinates relative to the center of the mountain.
            float azimuthalAngle = acosf(toMountainCenter.z / distance);
            float polarAngle = atan2f(toMountainCenter.y, toMountainCenter.x);
            
            float t = turbScale * [noiseSource0 noiseAtPointWithFourOctaves:vector_make(azimuthalAngle * freqScale,
                                                                                        polarAngle * freqScale,
                                                                                        0.0)];
            
            // Flatten the top.
            if(p.y > mountainCenter.y) {
                radius -= (p.y - mountainCenter.y) * 3;
            }
            
            floatingMountain = (distance+t) < radius;
        }
    }
    
    outVoxel->outside = NO; // calculated later
    outVoxel->torch = NO;
    outVoxel->opaque = groundLayer || floatingMountain;
    outVoxel->type = (groundLayer || floatingMountain) ? VOXEL_TYPE_GROUND : VOXEL_TYPE_EMPTY;
    outVoxel->texSide = VOXEL_TEX_DIRT;
    outVoxel->texTop = VOXEL_TEX_GRASS;
}